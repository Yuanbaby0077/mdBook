# 作用域和必包

## 变量作用域

全局变量拥有全局作用域，函数内声明的变量是局部变量，作用域只在函数体内。例如

```
var scope = 'global' // 全局变量

function fn() {
  var scope = 'local' // 同名全局变量会被局部变量覆盖
  return scope
}

console.log(fn()) // local
```

全局变量声明可以不用`var`,但局部变量声明必须使用`var`，否则：

```
_scope = 'global'
function checkScope() {
  _scope = 'local' // 修改了全局变量_scope
  myScope = 'local' // 新增了全局变量myScope
  return [_scope, myScope]
}

console.log(checkScope()) // [ 'local', 'local' ]
console.log(global._scope, global.myScope) // local local
```

## 函数作用域

函数作用域是指：函数中声明的所有变量在函数体内都是可见的。意味着，变量在声明之前已经可用，这个特性成为`声明提前`，即JavaScript函数里声明的所有变量（但不涉及赋值）都被提前到函数体的顶部。但变量初始化留在原来的位置上。

```
var __scope = 'global Scope'
function fnScope() {
  console.log(__scope) // undefined
  var __scope = 'function scope'
  console.log(__scope) // function scope
}
fnScope()
```

## 必包

概念：函数的执行依赖变量作用域，作用域是在函数定义的时候决定的而不是调用的时候决定的。函数对象可以通过作用域链关联起来，函数体内部的变量可以保存在函数作用域内，这种特性在计算机科学文献中成为必包。

通俗的讲，必包的概念看起来有点难以理解，先通过了解嵌套函数的词法作用域规则和作用域链来帮助理解必包。

### 作用域链

全局变量在程序中始终是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。
当定义一个函数时，实际上就保存一个作用域链。函数定义时的作用域链到函数执行的时候依然有效。

```
var ___scope = 'scope chain'
function chaninScope() {
  var ___scope = 'inner chain'
  function innerScope() {
    return ___scope
  }
  return innerScope()
}

console.log(chaninScope()) // inner chain

function chaninScope2() {
  var ____scope = 'inner chain'
  function innerScope() {
    return ____scope
  }
  return innerScope
}

console.log(chaninScope2()()) // inner chain
```

分析上面两种输出结果的原因：

Javascript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的， 嵌套的函数innerScope()定义在这个作用域链里，其中变量____scope一定是局部变量，不管何时何地执行嵌套的函数innerScope(),这种绑定在执行嵌套的函数innerScope()时依然有效。也就是说必包能捕捉到局部变量和参数并一直保存下来。

## 实现必包

```
function bibao() {
  var counter = 0
  return {
    count() {
      return counter ++
    },
    reset() {
      counter = 0
    }
  }
}

var b1 = bibao() var b2 = biao()

console.log(b1.count()) // 0
console.log(b2.count()) // 0

console.log(b1.count()) // 1
console.log(b2.count()) // 1
b1.reset()
console.log(b1.count()) // 0
console.log(b2.count()) // 2

```

上例中的私有变量`counter`不是只能用在一个单独的必包内，在同一个外部函数内定义的多个嵌套函数都能访问它，这多个嵌套函数共享一个作用域链。

每次调用`bibao`方法都会创建一个新的作用域链和新的私有变量，互不干扰。

```
function constfunc(v) {
  return () => v
}

var funcs = []
for(var i=0; i< 10; i++) {
  funcs[i] = constfunc(i)
}

console.log(funcs[5]()) // 5

function constfunc2() {
  var funcs = []
  console.log('i = ', i)
  for(var i=0; i< 10; i++) {
    funcs[i] = () => i
  }
  return funcs
}

console.log(constfunc2()[5]()) // 10

```
10个嵌套函数都是在同一个函数`constfunc2`中定义的，所以，这些必包可以共享变量`i`。当`constfunc2`返回时，i = 10,所有的必包都共享这个值。

## this




