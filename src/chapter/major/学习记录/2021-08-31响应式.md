# 响应式系统

`initState`

实现如下：

```
  function initState (vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) { initProps(vm, opts.props); }
    if (opts.methods) { initMethods(vm, opts.methods); }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) { initComputed(vm, opts.computed); }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }
```

`props,methods,data,computed,watch`的初始化处理。

依赖收集：Object.defineProperty设置getter方法时触发

* 为当前的watcher(该场景下是渲染watcher)添加拥有的数据。
* 为当前的数据收集需要监听的依赖，存在依赖管理器Dep中。
* 当值为对象时，会对对象的属性进行同样的操作。

派发更新：在Object.defineProperty设置setter方法，更新数据时触发，会通知到该数据收集的依赖管理器Dep，遍历watcher，进行数据更新。

* 判断数据更改前后是否一致，如果数据相等则不进行任何派发更新操作。
* 新值为对象时，会对该值的属性进行依赖收集过程。
* 通知该数据收集的watcher依赖,遍历每个watcher进行数据更新,这个阶段是调用该数据依赖收集器的dep.notify方法进行更新的派发。


```
Dep.prototype.notify = function notify () {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    if (!config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort(function (a, b) { return a.id - b.id; });
    }
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };
```
`notify`方法里主要是遍历当前数据收集的watcher，对watcher进行更新。
```
/**
  * Subscriber interface.
  * Will be called when a dependency changes.
  */
 Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher (watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;

        if (!config.async) {
          flushSchedulerQueue();
          return
        }
        nextTick(flushSchedulerQueue);
      }
    }
  }

  // 本质是利用事件循环的微任务队列实现异步更新。
  function nextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      })
    }
  }

  Watcher.prototype.run = function run () {
    if (this.active) {
      var value = this.get();
      if ( value !== this.value || isObject(value) || this.deep ) {
        // 设置新值
        var oldValue = this.value;
        this.value = value;
        // 针对user watcher，暂时不分析
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

// watcher的get方法主要功能是渲染页面组件
// 执行run操作会执行getter方法，也就是重新计算新值，针对渲染watcher而言，会重新执行  updateComponent进行视图更新
// 重新计算getter后，会进行依赖的清除

Watcher.prototype.get = function get () {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm); // this.getter即updateComponent
    } catch (e) {
     ···
    } finally {
      ···
      // 把Dep.target恢复到上一个状态，依赖收集过程完成
      popTarget();
      this.cleanupDeps();
    }
    return value
  };
  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };
```

## computed的原理

`computed`的初衷是为了简单运算，避免在模板中使用太多的逻辑运算，难以维护。通过`依赖收集`和`派发更新`二个过程进行分析。

### 初始化computed

遍历`computed`中的属性，每个属性都实例化一个watcher，`defineComputed`使进行响应式设置。
computed中属性的计算结果会被缓存起来，只有在相关的响应式数据发生改变后才会重新取值。
```
 function initComputed (vm, computed) {
    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(
          vm,
          getter || noop,
          noop,
          computedWatcherOptions
        );
      }

      defineComputed(vm, key, userDef);
    }
  }

  // computed watcher的标志，lazy属性为true
  var computedWatcherOptions = { lazy: true };

  function createComputedGetter (key) {
    return function computedGetter () {
      // 获取缓存中的computedWatcher
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) { // 标志是否已经执行过计算结果，如果执行过，就不会重新计算
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value
      }
    }
  }

  /**
   * Evaluate the value of the watcher. // 重新计算watcher的值
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate () {
    this.value = this.get(); // computed watcher 中执行的getter是计算函数
    this.dirty = false;
  };
```

```
watchers[key] = new Watcher(
  vm,
  getter || noop, // 计算属性key对应的计算函数
  noop,
  computedWatcherOptions
);
```

与data的依赖收集相比，computed会缓存运算结果，避免重复计算。

### computed watcher 的派发更新

发生在data中的数据发生变化，因此与data的逻辑一致。

computed watcher和之前介绍的watcher不同，它不会立刻执行依赖的更新操作，而是通过一个dirty进行标记。在实例化computed Watcher时，已经设置了 computedWatcherOptions： {
  lazy: true
}

```
Watcher.prototype.update = function update () {
  // 计算属性分支  
  if (this.lazy) { // 如果lazy属性，将dirty设置为true，不执行更新操作
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
```
由于data数据拥有渲染watcher这个依赖，所以同时会执行updateComponent进行视图重新渲染,而render过程中会访问到计算属性,此时由于this.dirty值为true,又会对计算属性重新求值。


## nextTick

```
var callbacks = [];
var pending = false;
var timerFunc;
function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) { // pending是判断是否在等待执行微任务队列的标志
    pending = true;
    timerFunc(); // 将维护的队列推到微任务队列中维护
  } 
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

// timerFunc是真正将任务队列推到微任务队列中的函数
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
  };
  isUsingMicroTask = true;
}

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}
```
不支持promise,支持MutataionObserver

```
if (!isIE && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
    isUsingMicroTask = true;
  } 
```

如果不支持微任务方法，则会使用宏任务方法，setImmediate会先被使用


```
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Techinically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
      setImmediate(flushCallbacks);
    };
  }
```

所有方法都不适合，会使用宏任务方法中的setTimeout
// Fallback to setTimeout.
timerFunc = function () {
  setTimeout(flushCallbacks, 0);
};

