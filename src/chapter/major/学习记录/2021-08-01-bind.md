# 实现bind方法

## 需求

```
var o = {
  z: 2
}
function add(x, y) {
  console.log('=======', this)
  return this.z + x + y
}

```
1、 `_bind`方法是`Function.prototype`原型上的一个方法
2、 执行`add._bind(o, 3)`，`add`函数可以通过`_bind`方法，将对象`o`作为函数执行上下文，并将其余参数作为参数传入`add`函数中
3、 `_bind`方法返回一个函数，其传入的参数是`add`的剩余参数
4、 `_bind`方法返回的函数，用作构造函数，将忽略`_bind`传入的`this`，原始函数`add`就会以构造函数的形式调用。
5、构造函数创建的对象的`__proto__`指向构造函数`add`的`prototype`

##实现
```
Function.prototype._bind = function(o) { // 1
  const self = this
  const args = [...arguments].slice(1)
  const fn = function() { // 3
    const fnArgs = [...arguments].slice(0)
    const _args = args.concat(fnArgs) // 2
    this.z = 6
    return self.apply(this instanceof fn ? this : o, _args) // 4
  }
  console.log(this)
  fn.prototype = this.prototype
  return fn
}
```
## 测试
```
var bindFn = add._bind(o, 3)
var res = bindFn(4)
console.log(res)

var bindCtor = new bindFn(5)

var _bindFn = add.bind(o, 11)
var realBindCtol = new _bindFn(8)
```