# Node.js 模块

## require

在node.js中，文件即模块，使用 require，exports/module.exports来导入/导出模块

### export和module.exports 的区别

exports指向module.exports的引用地址
`module.exports === exports // true`
直接修改exports对象不会对module.exports产生影响，如：
```
exports = {
  id: 123
}
```

此时的exports指向了新的地址，与module.exports不等

直接修改exports中的属性，二者依然指向同一个引用地址。

```
exports.name = 'az'
console.log(module.exports === exports) // true
```

执行 module打印出来的结果是

```
Module {
  id: '<repl>',
  path: '.',
  exports: {},
  parent: undefined,
  filename: null,
  loaded: false,
  children: [],
  paths: [
    '/www/mdbook/mdBook/repl/node_modules',
    '/www/mdbook/mdBook/node_modules',
    '/www/mdbook/node_modules',
    '/www/node_modules',
    '/node_modules',
    '/Users/creamlin/.node_modules',
    '/Users/creamlin/.node_libraries',
    '/Users/creamlin/.nvm/versions/node/v12.13.1/lib/node'
  ]
}
```

其中module.paths枚举了一系列的绝对路径，是模块可能出现的node_modules路径。

执行require('a')，在以上的paths路径下查找`a`，会报找不到模块

```
require('a')
Thrown:
Error: Cannot find module 'a'
Require stack:
- <repl>
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)
    at Function.Module._load (internal/modules/cjs/loader.js:690:27)
    at Module.require (internal/modules/cjs/loader.js:852:19)
    at require (internal/modules/cjs/helpers.js:74:18) {
  code: 'MODULE_NOT_FOUND',
  requireStack: [ '<repl>' ]
}
```

创建node_modules/a/index.js
```
> require('a')
module a
{}
```

文件名缺省的情况，默认会找到文件夹下的`index.js`文件来执行，可以在`package.json`中配置`main: "${entry}.js"`来指定入口文件。
比如，当前a模块下只有c.js
package.json配置：
```
{
  "name": "a",
  "main": "main.js"
}
```
执行 node require('a')，会报，main配置的js找不到
```
require('a')
Thrown:
Error: Cannot find module '/www/tsDemo/node_modules/a/main.js'. Please verify that the package.json has a valid "main" entry
    at tryPackage (internal/modules/cjs/loader.js:297:19)
    at Function.Module._findPath (internal/modules/cjs/loader.js:528:18)
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:784:27)
    at Function.Module._load (internal/modules/cjs/loader.js:690:27)
    at Module.require (internal/modules/cjs/loader.js:852:19)
    at require (internal/modules/cjs/helpers.js:74:18) {
  code: 'MODULE_NOT_FOUND',
  path: '/www/tsDemo/node_modules/a/package.json',
  requestPath: 'a'
}
```
在a模块下添加`main.js`即可

```
> require('a')
这是A模块
{}
```

### require.resove

使用内部的 `require()` 机制查询模块的位置，此操作只返回解析后的文件名，不会加载该模块。

如果找不到模块，则会抛出 `MODULE_NOT_FOUND` 错误。

```
> require.resolve('a')
'/www/tsDemo/node_modules/a/main.js'
```

### 模块依赖

```
# main.js
var sub = require('./sub')
console.log(sub)
console.log(module)
```
输出
```
Module {
  id: '.',
  path: '/www/tsDemo/src/node/node_modules/a',
  exports: {},
  parent: null,
  filename: '/www/tsDemo/src/node/node_modules/a/main.js',
  loaded: false,
  children: [
    Module {
      id: '/www/tsDemo/src/node/node_modules/a/sub.js',
      path: '/www/tsDemo/src/node/node_modules/a',
      exports: [Object],
      parent: [Circular],
      filename: '/www/tsDemo/src/node/node_modules/a/sub.js',
      loaded: true,
      children: [],
      paths: [Array]
    }
  ],
  paths: [
    '/www/tsDemo/src/node/node_modules/a/node_modules',
    '/www/tsDemo/src/node/node_modules',
    '/www/tsDemo/src/node_modules',
    '/www/tsDemo/node_modules',
    '/www/node_modules',
    '/node_modules'
  ]
}
```

可以看到main.js中引入了sub.js形成了依赖关系。

Node.js模块的加载是同步的，其中的loaded属性在模块加载完成后，会变为true，否则就默认是false。

通过`setImmediate`来模拟打印出来的`loaded: true`

```
setImmediate(() => {
  console.log(module)
})
```

node 模块的循环依赖，见demo1,demo2，执行 `node demo1.js`，得到的结果是

```
node demo1.js
Module1 is partially loaded here { a: 1 }
```

只输出了部分exports对象的内容，即只有发生循环依赖前的属性被导出。

### require.extensions

在node.js中，require()中不需要显示声明即可支持的文件类型有：
```
require.extensions
[Object: null prototype] {
  '.js': [Function],
  '.json': [Function],
  '.node': [Function],
  '.mjs': [Function]
}
```

文件后缀的匹配优先级为：.js > .json > .node > .mjs

## 模块包装

node.js模块中的变量具有私有作用域，在其他模块中不能直接访问，与js中的全局作用域不一样。

node.js的私有作用域是通过函数来处理，最终返回module.exports，模块内容暴露出来，以供使用。
```
require('module').wrapper
Proxy [
  [
    '(function (exports, require, module, __filename, __dirname) { ',
    '\n});'
  ],
  { set: [Function: set], defineProperty: [Function: defineProperty] }
]
```

## 缓存

一个模块中多次引用另一个模块，只会执行一次，第二次引用的时候取的是缓存的内容，无需重新加载模块。

可以通过require.cache来查看当前缓存的模块。